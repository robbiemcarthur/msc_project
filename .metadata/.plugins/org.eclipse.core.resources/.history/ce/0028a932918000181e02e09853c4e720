package KnowledgeGraph;


public class DLL {
	// Each DLL object is the header of a doubly-linked list

	private Node first, last;

	public DLL() {
		// construct empty DLL
		first = null;
		last = null;
	}

	///////// Inner class /////////

	private static class Node {
		private Object element;
		private Node pred, next;

		public Node(Object elem, Node pred, Node next) {
			this.element = elem;
			this.pred = pred;
			this.next = next;
		}
	}

	public void printLastToFirst() {
		// print all elements in this SLL, in first-to-last order
		Node curr = this.last;
		while(curr!=null) {
			System.out.print(curr.element);
			curr = curr.pred;
		}
	}

	public void printFirstToLast() {
		// print all elements in this SLL, in first-to-last order
		Node curr = this.first;
		while(curr!=null) {
			System.out.print(curr.element);
			curr = curr.next;
		}
	}

	public void deleteFirst() {
		// delete this SLL's first node (assuming length > 0)
		Node second = first.next;
		second.pred = null;
		first = second;
	}

	public void deleteLast() {
		// delete this DLL's last node, assuming length > 0
		Node penult = last.pred;
		penult.next = null;
		last = penult;
	}

	public void insert(Object elem, Node pred) {
		/**
		 * insert elem at a given point in this DLL, either after the 
		 * node pred, or before the first node if pred is null 
		 */
		Node ins = new Node(elem, null, null);
		insertNodeForwards(ins, pred);
		Node next = ins.next;
		insertNodeBackwards(ins, next);
	}

	public void insertNodeForwards(Node ins, Node pred) {
		if(pred == null) {
			ins.next = first;
			first = ins;
		}
		else {
			ins.next = pred.next;
			pred.next = ins;
		}
	}

	public void insertNodeBackwards(Node ins, Node next) {
		if (next == null) {
			ins.pred = last;
			last = ins;
		}
		else {
			ins.pred = next.pred;
			next.pred = ins;
		}
	}

	public void delete(DLL.Node del) {
		// delete Node del from this DLL 
		Node next = del.next;
		if(del == this.first) {
			this.first = next;
		}
		else {
			Node pred = this.first;
			while(pred.next != del) {
				pred = pred.next;
			}
			pred.next = next;
		}
	}

	public Node search(Object target) {
		/**
		 * find which, if any, node of this SLL contains an
		 * element equal to target. Return a link to the 
		 * matching node, or null if there is none
		 */
		Node curr = this.first;
		while(curr != null) {
			if(target.equals(curr.element))
			{
				System.out.println("\n\nfound " + target);
				return curr;
			}
			curr = curr.next;
		}
		return null;
	}
}
